{
  "version": 3,
  "sources": ["../src/monitor.ts", "../node_modules/@yigal/base_types/src/index.ts", "../src/test.ts"],
  "sourcesContent": ["import * as path from \"node:path\";\nimport { ChildProcessWithoutNullStreams,spawn } from \"child_process\";\nimport {\n  is_object,\n  s2t,\n  mkdir_write_file,\n  read_json_object ,\n  s2u,\n  reset,\n  green,\n  is_string_array,\n  s2s,\n  get_error,\n  sleep\n} from \"@yigal/base_types\";\ninterface Watcher{\n  watch?:string[]\n  filter?:string\n  pre?:string\n}\nexport type Scriptsmon=  Record<string,Watcher|string[]>&\n{\n  $watch?:string[]\n  autorun?:string[]\n}\ntype State=\"ready\"|\"done\"|\"crashed\"|\"running\"|\"failed\"|\"spawning\"|\"stopped\"\nfunction is_ready_to_start(state:State){\n  return state!==\"running\"&&state!==\"spawning\"\n}\ntype StrType='stderr'|'stdout'\ninterface Mystring{\n  type:StrType \n  data:string\n}\nexport interface RunnerBase extends Watcher{//adds some runtime\n  type           : 'runner'\n  name           : string\n  full_pathname  : string            //where the package.json is   \n  script         : string            //coming from the scripts section of package.json\n  autorun        : boolean\n  state          : State\n  last_start_time: number|undefined\n  last_end_time  : number|undefined\n  \n  start_time      : number|undefined\n  reason          : string\n  last_reason     : string\n  last_err        : Error|undefined\n  output          : Mystring[] \n  id              : string//unique aacross runners\n\n}\nexport const runner_base_keys:(keyof RunnerBase)[]=[\n  \"watch\",\n  \"filter\",\n  \"pre\",\n  \"type\",          \n  \"name\",\n  \"full_pathname\",\n  \"script\",\n  \"autorun\",      \n  \"state\",     \n  \"last_start_time\",\n  \"last_end_time\",\n  \"start_time\",\n  \"reason\",  \n  \"last_reason\",\n  \"last_err\",\n  \"output\",\n  \"id\"\n]\n\nexport interface Runner extends RunnerBase{\n  abort_controller: AbortController\n  child           : ChildProcessWithoutNullStreams|undefined\n  start           : (reason:string)=>Promise<void>    \n}\n\nexport interface Folder{\n  type:'folder'\n  name:string \n  full_pathname: string //where the package.json is \n  folders:Array<Folder>\n  runners:Array<Runner>\n  scriptsmon:Scriptsmon\n}\nfunction is_valid_watch(a:unknown){\n  if (a==null)\n    return true\n  return is_string_array(a)\n}\nfunction is_valid_watcher(a:unknown){\n  if (typeof a==='string' || is_string_array(a))\n      return true \n  if (!is_object(a))\n    return \"expecting object\"\n  if (!is_valid_watch(a.watch)){\n    return 'watch: expecting  array of strings'\n  }\n\n  for (const k of Object.keys(a))\n    if (!['watch','env','filter','pre'].includes(k))\n      return `${k}:invalid key`\n  return true\n}\nfunction is_non_watcher(k:string){\n  return  (['autorun','$watch'].includes(k))\n}\nfunction is_config2(a:unknown){\n  if (!is_object(a))\n    return false\n  const {$watch}=a\n  if (!is_valid_watch($watch)){\n    console.log('watch: must be string or array of string')\n    return false  \n  }\n  for (const [k,v] of Object.entries(a)){\n    if (is_non_watcher(k))\n      continue\n    const valid_watcher=is_valid_watcher(v)\n    if (valid_watcher!==true){\n      console.log(`${k}: invalid watcher:${valid_watcher}`)\n      return false\n    }\n\n  }\n  return true\n\n}\nfunction parse_config(filename:string,pkgJson:s2u|undefined):Scriptsmon{\n  if (pkgJson==null)\n    return{}\n  const {scriptsmon}=pkgJson\n  if (scriptsmon==null)\n    return {}\n  const ans=is_config2(scriptsmon);\n  if (ans)\n    return scriptsmon as Scriptsmon\n  console.warn(ans)\n  return {}  \n}\nfunction parse_scripts(pkgJson:s2u):s2s{\n\n  if (pkgJson==null)\n    return {}\n  const {scripts}=pkgJson\n  if (scripts==null)\n    return {}  \n  return scripts as s2s\n}\nfunction normalize_watch(a:string[]|undefined){\n  if (a==null)\n    return []\n  return a\n}\nfunction run_runner({ //this is not async function on purpuse\n  runner,\n  reason\n}: {\n  runner: Runner;\n  reason:string\n}) {\n  const {abort_controller}=runner\n  const {signal}=abort_controller\n  void new Promise((resolve, _reject) => { \n    const {script,full_pathname}=runner\n    runner.state='spawning'\n    const child = spawn(script, {\n      signal,\n      shell: true,\n      env: { ...process.env, FORCE_COLOR: \"1\",cwd:full_pathname },  \n    });\n    if (child===null)\n      return\n    child.stdout.on(\"data\",(data:unknown)=>runner.output.push({data:String(data),type:'stdout'}))\n    child.stderr.on(\"data\",(data:unknown)=>runner.output.push({data:String(data),type:'stdout'}))\n    child.on('spawn',()=>{\n      runner.start_time=Date.now()\n      runner.state='running'\n      runner.reason=reason\n    })\n\n    child.on(\"exit\", (code) => {\n      runner.state=(code===0?'done':'crashed') //todo: should think of aborted\n      runner.last_end_time=Date.now()\n      runner.last_start_time=runner.start_time\n      runner.start_time=undefined\n      runner.last_reason=runner.reason\n      resolve(null);\n    });\n\n    child.on(\"error\", (err) => {\n      runner.state='failed'\n      runner.last_err=get_error(err)\n      resolve(null);\n    });\n  });\n}\nasync function stop(runner: Runner): Promise<void> {\n  const { state,abort_controller,abort_controller:{signal} } = runner;\n  let was_stopped=false\n  while(true){\n    if (is_ready_to_start(runner.state)) {\n      if (was_stopped)\n        runner.state='stopped'\n      return Promise.resolve()\n    }\n    signal.addEventListener('abort', () => was_stopped=true, { once: true });\n    await sleep(10)\n  }\n}\nfunction make_start(runner:Runner){\n  return  async function(reason:string){\n    await stop(runner)\n    run_runner({runner,reason})\n\n  }\n  \n}\nfunction scriptsmon_to_runners(pkgPath:string,watchers:Scriptsmon,scripts:s2s){\n  const $watch=normalize_watch(watchers.$watch)\n  const autorun=normalize_watch(watchers.autorun)\n  const ans=[]\n  for (const [name,script] of Object.entries(scripts)){\n    if (is_non_watcher(name))\n      continue\n    const watcher:Watcher=function(){\n      const v=watchers[name]\n      if (v==null||is_string_array(v)){\n        return {watch:normalize_watch(v)}\n      }\n      return v\n    }()\n    //const script=scripts[name]\n    if (script==null){\n      console.warn(`missing script ${name}`)\n      continue\n    }\n    const runner=function(){\n      const full_pathname=path.dirname(pkgPath)\n      const ans:Runner= {\n        type:'runner',\n        ...watcher, //i like this\n        name,\n        script,\n        full_pathname,\n        watch:[...normalize_watch($watch),...normalize_watch(watcher.watch)],\n        autorun:autorun.includes(name),\n        state:'ready',\n        child:undefined,\n        start_time:0,\n        last_end_time:undefined,\n        last_start_time:undefined,\n        start:(reason:string)=>Promise.resolve(),\n        reason:'',\n        last_reason:'',\n        last_err:undefined,\n        abort_controller:new AbortController(),\n        output:[],\n        id:`${full_pathname} ${name}`\n      }\n      ans.start=make_start(ans)\n      return ans\n    }()\n    ans.push(runner)\n  }\n  return ans\n}\nexport async function read_package_json(\n  full_pathnames: string[]\n) {\n\n  const folder_index: Record<string, Folder> = {}; //by full_pathname\n  async function f(full_pathname: string,name:string){\n    const pkgPath = path.resolve(path.normalize(full_pathname), \"package.json\");\n    const d= path.resolve(full_pathname);\n    const exists=folder_index[d]\n    if (exists!=null){\n      console.warn(`${pkgPath}: skippin, already done`)\n      return exists\n    }    \n    //const pkgJson = await \n    const pkgJson=await read_json_object(pkgPath,'package.json')\n    if (pkgJson==null)\n      return null\n    console.warn(`${green}${pkgPath}${reset}`)\n    const scriptsmon=parse_config(pkgPath,pkgJson)\n    const scripts=parse_scripts(pkgJson)\n    const runners=scriptsmon_to_runners(pkgPath,scriptsmon,scripts)\n    const {workspaces} = pkgJson\n    const folders=[]\n    if (is_string_array(workspaces))\n      for (const workspace of workspaces){\n          const ret=await f(path.join(full_pathname,workspace),workspace)\n          if (ret!=null)\n            folders.push(ret)\n        }\n\n    \n    const ans:Folder= {runners,folders,name,full_pathname,scriptsmon,type:'folder'}\n    return ans\n  }\n  const folders=[]\n  for (const pathname of full_pathnames){\n    const full_pathname=path.resolve(pathname)\n    const ret=await f(full_pathname,path.basename(full_pathname))\n      if (ret!=null)\n        folders.push(ret)\n  }\n  const root:Folder={\n    name:'root',\n    full_pathname: '',\n    folders,\n    runners:[],\n    scriptsmon:{},\n    type:'folder'\n  }\n  //const keys=Object.keys(ans)\n  //const common_prefix=getCommonPrefix(keys)\n  //const extra={keys,common_prefix}\n  //await mkdir_write_file('generated/extra.json',JSON.stringify(extra,null,2))\n  await mkdir_write_file('c:\\\\yigal\\\\generated\\\\packages.json',JSON.stringify(root,null,2))\n  return root\n}\n", "export type s2t<T> = Record<string, T>\nexport type s2u = Record<string, unknown>\nexport type p2u = Record<PropertyKey, unknown> \nexport const green='\\x1b[40m\\x1b[32m'\nexport const red='\\x1b[40m\\x1b[31m'\nexport const yellow='\\x1b[40m\\x1b[33m'\n\nexport const reset='\\x1b[0m'\nexport function nl<T>(value: T | null | undefined): T {\n  //todo:check only active on debug mode\n  //return value\n  if (value === null || value === undefined) {\n    throw new Error('Value cannot be null or undefined')\n  }\n  return value\n}\nexport type Key = number | string //should i use properykey for this?\nexport type Atom = number | string | boolean \nexport function is_atom(x: unknown): x is Atom {\n  if (x == null) return false\n  return ['number', 'string', 'boolean'].includes(typeof x)\n}\nexport function is_key(x: unknown): x is Key {\n  if (x == null) return false\n  return ['number', 'string'].includes(typeof x)\n}\nexport function is_atom_ex(v: unknown, place: string, k = ''): v is Atom {\n  if (is_atom(v)) return true\n  console.warn('non-atom', place, k, v)\n  return false\n}\nexport function get_error(x:unknown){\n  if (x instanceof Error)\n    return x\n  const str = String(x)\n  return new Error(str)\n}\nexport function is_object<T extends object=s2u>(value: unknown): value is T{\n  if (value == null) return false;\n  \n  // Accept objects and functions\n  if (typeof value !== 'object' && typeof value !== 'function') return false;\n  \n  // Exclude known non-object types\n  if (Array.isArray(value)) return false;\n  if (value instanceof Set) return false;\n  if (value instanceof Map) return false;\n  \n  return true;\n}\nexport function has_key(obj: unknown, k: string): boolean {\n  if (!is_object(obj)) return false\n  return k in obj\n}\nexport function* objects_only(ar:unknown[]){\n  for (const item of ar)\n    if (is_object(item))\n      yield item\n}\n\nexport function has_keys(obj: unknown, keys: string[]): boolean {\n  if (!is_object(obj)) return false\n  for (const k of keys) if (k in keys) return true\n  return false\n}\nexport type strset = Set<string>\nexport type s2num = Record<string, number>\nexport type s2s = Record<string, string>\nexport type num2num = Record<number, number>\n\nexport function pk<T, K extends keyof T>(obj: T | undefined, ...keys: K[]): Pick<T, K> {\n  const ret: Record<PropertyKey,unknown> = {} \n  keys.forEach((key) => {\n    ret[key] = obj?.[key]\n  })\n  return ret as Pick<T, K> \n}\nexport function is_promise<T=void>(value: unknown): value is Promise<T> { ///ts(2677)\n  if (!is_object(value))\n    return false\n\n  const ans=typeof (value.then)==='function'\n  return ans\n}\ntype MaybePromise<T>=T|Promise<T>\nasync function resolve_maybe_promise<T>(a:MaybePromise<T>){\n  if (is_promise(a))\n    return await a\n  return a\n}\n      \nexport interface Test{\n  k?:string,\n  v?:Atom,\n  f:()=>MaybePromise<Atom>\n}\n\nexport async function run_tests(...tests: Test[]) {\n  let passed = 0\n  let failed = 0\n  \n  for (const {k,v,f} of tests) {\n    const ek=function(){\n      if (k!=null)\n        return k\n      const fstr=String(f)\n      {\n        const match=fstr.match(/(\\(\\) => )(.*)/)\n        if (match?.length===3)\n          return match[2]\n      }\n      {\n        const match=fstr.match(/function\\s(\\w+)/)\n        if (match?.length===2)\n          return match[1]      \n      }\n      return\n    }()\n    try {\n      const ret=f()\n      const effective_v=v??true\n      const resolved = await resolve_maybe_promise(ret)\n      if (resolved===effective_v){\n        console.log(`\u2705 ${ek}: ${green}${effective_v}${reset}`)\n        passed++\n      } else {\n        console.error(`\u274C ${ek}:expected ${yellow}${effective_v}${reset}, got ${red}${resolved}${reset}`)\n        failed++\n      }\n    } catch (err) {\n      console.error(`\uD83D\uDCA5 ${ek} threw an error:`, err)\n      failed++\n    }\n  }\n  if (failed===0)\n    console.log(`\\nSummary:  all ${passed} passed`)  \n  else\n    console.log(`\\nSummary:  ${failed} failed, ${passed} passed`)  \n}\n\n\nexport function getCommonPrefix(paths: string[]): string {\n  if (paths.length === 0) return \"\";\n  if (paths.length === 1) return paths[0];\n\n  // Split each path into parts (e.g., by \"/\" or \"\\\\\")\n  const splitPaths = paths.map(p => p.split(/[\\\\/]+/));\n\n  const commonParts: string[] = [];\n  const first = splitPaths[0];\n\n  for (let i = 0; i < first.length; i++) {\n    const part = first[i];\n    if (splitPaths.every(p => p[i] === part)) {\n      commonParts.push(part);\n    } else {\n      break;\n    }\n  }\n\n  // Join back with \"/\" (or use path.join for platform-specific behavior)\n  return commonParts.join(\"/\");\n}\n\n\nasync function get_node(){\n  if (typeof window !== \"undefined\") {\n    throw new Error(\"getFileContents() requires Node.js\");\n  }\n  const path = await import(\"node:path\");\n  const fs = await import(\"node:fs/promises\");\n  return {fs,path}  \n}\nexport async function mkdir_write_file(filePath:string,data:string){\n  const {path,fs}=await get_node()\n  const directory=path.dirname(filePath);\n  try{\n    await fs.mkdir(directory,{recursive:true});\n    await fs.writeFile(filePath,data);\n    console.log(`File '${filePath}' has been written successfully.`);\n  } catch (err){\n    console.error('Error writing file',err)\n  }\n}\nexport async function read_json_object(filename:string,object_type:string){\n  const {fs}=await get_node()\n  try{\n    const data=await fs.readFile(filename, \"utf-8\");\n    const ans=JSON.parse(data) as unknown\n    if (!is_object(ans))\n      throw `not a valid ${object_type}`\n    return ans\n  }catch(ex:unknown){\n    console.warn(`${filename}:${get_error(ex)}.message`)\n    return undefined\n  }\n}\nexport function is_string_array(a:unknown):a is string[]{\n  if (!Array.isArray(a))\n    return false\n  for (const x of a)\n    if (typeof x!=='string')\n      return false\n  return true  \n}\n\nexport async function sleep(ms: number) {\n  return await new Promise((resolve) => {\n    setTimeout(() => resolve(undefined), ms);\n  });\n}", "import {read_package_json} from './monitor.js'\nimport {run_tests} from '@yigal/base_types'\nasync function get_package_json_length(){\n  const ans=await read_package_json(['.','..\\\\million_try3'])\n  return Object.keys(ans).length\n}\nif (import.meta.main) {\n  void run_tests({\n    k:'run on self',\n    v:5,\n    f:get_package_json_length\n  })\n}\n \n "],
  "mappings": "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",
  "names": ["path", "resolve", "resolve", "ans", "folders"]
}
