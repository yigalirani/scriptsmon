{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/monitor.ts", "../node_modules/@yigal/base_types/src/index.ts"],
  "sourcesContent": ["import * as path from 'node:path';\nimport * as fs from 'node:fs';\nimport {read_package_json,type Runner,type Folder,type RunnerBase,runner_base_keys} from './monitor.js'\nimport * as vscode from 'vscode';\nimport {pk} from '@yigal/base_types'\nexport {type RunnerBase,runner_base_keys}\ntype MonitorNode=Runner|Folder\n\n\nexport interface WebviewMessageSimple {\n  command: \"buttonClick\"|\"updateContent\"|\"get_report\";\n  text?: string;\n}\nexport interface RunnerReport{\n   command: \"RunnerReport\";\n   runners:RunnerBase[]\n}\nexport type WebviewMessage=WebviewMessageSimple|RunnerReport\nfunction make_runner_report(root:Folder):RunnerReport{\n  const runners:RunnerBase[]=[]\n  function f(folder:Folder){\n    for (const runner of folder.runners){\n      const runner_base:RunnerBase=pk(runner,...runner_base_keys)\n      runners.push(runner_base)\n    }\n    for (const subfolder of folder.folders){\n      f(subfolder)\n    }\n  }\n  f(root)\n  return {runners,command: \"RunnerReport\"}\n}\n    function calc_icons_paths(){\n\n    }\n\nclass IconPaths{\n  folderIconPath:vscode.Uri|undefined\n  fileIconPath:vscode.Uri|undefined\n  constructor(\n    public context: vscode.ExtensionContext,\n    public changed:vscode.EventEmitter<undefined>\n  ){\n    this.calc_paths()\n    vscode.window.onDidChangeActiveColorTheme(() => {\n      this.calc_paths()\n      this.changed.fire(undefined)\n    })\n  }\n  calc_paths(){\n    const isDark = vscode.window.activeColorTheme.kind === vscode.ColorThemeKind.Dark || \n                  vscode.window.activeColorTheme.kind === vscode.ColorThemeKind.HighContrast\n    const themeSuffix = isDark ? 'dark' : 'light'\n    this.folderIconPath=vscode.Uri.joinPath(this.context.extensionUri, 'client','resources', 'icons', `folder-${themeSuffix}.svg`)\n    this.fileIconPath = vscode.Uri.joinPath(this.context.extensionUri, 'client','resources', 'icons', `file-${themeSuffix}.svg`)    \n  }\n}\n\nexport class MonitorProvider implements vscode.TreeDataProvider<MonitorNode> {\n  root\n  paths\n  changed = new vscode.EventEmitter<undefined>();\n  onDidChangeTreeData = this.changed.event;  \n\n  constructor( root: Folder, context: vscode.ExtensionContext) {\n    this.root=root\n    this.paths=new IconPaths(context,this.changed)\n  }\n\n  getTreeItem(element: MonitorNode): vscode.TreeItem {\n    const ans={label:element.name}\n    if (element.type==='folder')\n      return {...ans,\n        collapsibleState:2,\n        iconPath:this.paths.folderIconPath,\n        description:element.full_pathname\n      }\n    return {...ans,\n      collapsibleState:0,\n      iconPath:this.paths.fileIconPath,\n      description:element.script,\n      contextValue:'runner'\n    }\n  }\n\n  getChildren(element?: MonitorNode): Thenable<MonitorNode[]> {\n    if (!this.root) {\n      vscode.window.showInformationMessage('No Monitor in empty workspace');\n      return Promise.resolve([]);\n    }\n    if (element==null)\n      return Promise.resolve(this.root.folders)\n    if (element.type==='runner')\n      return Promise.resolve([])\n    return Promise.resolve([...element.folders,...element.runners])\n  }\n}\n\nfunction getWebviewContent(context: vscode.ExtensionContext, webview: vscode.Webview): string {\n  const htmlPath = path.join(context.extensionPath, 'client','resources', 'index.html');\n  let html = fs.readFileSync(htmlPath, 'utf-8');\n  \n  // Get URIs for CSS and JS files\n  const base = webview.asWebviewUri(\n    vscode.Uri.joinPath(context.extensionUri,'client','resources')\n  ).toString()+'/'\n\n  \n  // Replace placeholders with actual URIs\n  html = html.replaceAll('./', base);\n\n  \n  return html;\n}\n\nfunction createWebviewPanel(context: vscode.ExtensionContext,root:Folder): vscode.WebviewPanel {\n  let counter=0\n\n  const panel = vscode.window.createWebviewPanel(\n    'scriptsmonWebview',\n    'Scriptsmon Webview',\n    vscode.ViewColumn.One,\n    {\n      enableScripts: true,\n      retainContextWhenHidden: true\n    }\n  );\n  function send_report(root:Folder){\n    const report=make_runner_report(root)\n    panel.webview.postMessage(report)\n  }  \n  // Load content from static file\n  panel.webview.html = getWebviewContent(context, panel.webview);\n  \n  // Handle messages from the webview\n  panel.webview.onDidReceiveMessage(\n    (message: WebviewMessage) => {\n      switch (message.command) {\n        case 'get_report':\n          send_report(root)\n          break\n        case 'buttonClick':\n          counter++\n          vscode.window.showInformationMessage(`Received: ${message.text ?? ''}`);\n          // Send message back to webview\n          panel.webview.postMessage({\n            command: 'updateContent',\n            text: `Extension received: ${message.text ?? ''},extension counter=${counter}`\n          });\n          break;\n      }\n    },\n    undefined,\n    context.subscriptions\n  );\n\n  return panel;\n}\n\nexport async function activate(context: vscode.ExtensionContext) {\n  console.log('Congratulations, your extension \"Scriptsmon\" is now active!');\n  const outputChannel = vscode.window.createOutputChannel(\"Scriptsmon\");  \n  vscode.tasks.onDidEndTaskProcess((event) => {\n    outputChannel.append(JSON.stringify(event,null,2))\n  })\n  const {workspaceFolders: _workspaceFolders}= vscode.workspace\n  //const folders=(workspaceFolders||[]).map(x=>x.uri.fsPath)\n  //const folders=[\"c:\\\\yigal\\\\million_try3\"]\n  const folders=[\"c:\\\\yigal\\\\scriptsmon\"]\n  const root=await  read_package_json(folders)\n  const treeView=vscode.window.createTreeView('Scriptsmon.tree', {\n    treeDataProvider: new MonitorProvider(root, context)\n  })\n  context.subscriptions.push(treeView)\n\n  const focusDisposable=treeView.onDidChangeSelection((event)=>{\n    const selected=event.selection?.[0]\n    if (!selected || selected.type!=='runner')\n      return\n    const terminalName=`${selected.full_pathname} ${selected.name}`\n    const terminal=vscode.window.terminals.find(t=>t.name===terminalName)\n    if (terminal)\n      terminal.show()\n  })\n  context.subscriptions.push(focusDisposable)\n\n  const disposable = vscode.commands.registerCommand('Scriptsmon.start',  () => {\n    outputChannel.append('start')\n  });\n  context.subscriptions.push(disposable);\n\n  const playDisposable = vscode.commands.registerCommand('Scriptsmon.runner.play', async (runner: Runner) => {\n    if (!runner || runner.type !== 'runner') {\n      vscode.window.showErrorMessage('Invalid runner');\n      return;\n    }\n    await runner.start('user')\n\n  });\n  context.subscriptions.push(playDisposable);\n\n  const debugDisposable = vscode.commands.registerCommand('Scriptsmon.runner.debug', (runner: Runner) => {\n    if (!runner || runner.type !== 'runner') {\n      vscode.window.showErrorMessage('Invalid runner');\n      return;\n    }\n\n    const terminalName = `${runner.full_pathname} ${runner.name} (debug)`;\n\n    let terminal = vscode.window.terminals.find(t => t.name === terminalName);\n    if (!terminal) {\n      terminal = vscode.window.createTerminal({\n        name: terminalName,\n        cwd: runner.full_pathname\n      });\n    }\n\n    terminal.show();\n    terminal.sendText(`npm run ${runner.name}`);\n\n    outputChannel.appendLine(`Debugging script: ${runner.name} in ${runner.full_pathname} (terminal: ${terminalName})`);\n  });\n  context.subscriptions.push(debugDisposable);\n\n  const webviewDisposable = vscode.commands.registerCommand('Scriptsmon.webview.open', () => {\n    const panel = createWebviewPanel(context,root);\n    context.subscriptions.push(panel);\n  });\n  context.subscriptions.push(webviewDisposable);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() {}\n\n", "import * as path from \"node:path\";\nimport { ChildProcessWithoutNullStreams,spawn } from \"child_process\";\nimport {\n  is_object,\n  s2t,\n  mkdir_write_file,\n  read_json_object ,\n  s2u,\n  reset,\n  green,\n  is_string_array,\n  s2s,\n  get_error,\n  sleep\n} from \"@yigal/base_types\";\ninterface Watcher{\n  watch?:string[]\n  filter?:string\n  pre?:string\n}\nexport type Scriptsmon=  Record<string,Watcher|string[]>&\n{\n  $watch?:string[]\n  autorun?:string[]\n}\ntype State=\"ready\"|\"done\"|\"crashed\"|\"running\"|\"failed\"|\"spawning\"|\"stopped\"\nfunction is_ready_to_start(state:State){\n  return state!==\"running\"&&state!==\"spawning\"\n}\ntype StrType='stderr'|'stdout'\ninterface Mystring{\n  type:StrType \n  data:string\n}\nexport interface RunnerBase extends Watcher{//adds some runtime\n  type           : 'runner'\n  name           : string\n  full_pathname  : string            //where the package.json is   \n  script         : string            //coming from the scripts section of package.json\n  autorun        : boolean\n  state          : State\n  last_start_time: number|undefined\n  last_end_time  : number|undefined\n  \n  start_time      : number|undefined\n  reason          : string\n  last_reason     : string\n  last_err        : Error|undefined\n  output          : Mystring[] \n  id              : string//unique aacross runners\n\n}\nexport const runner_base_keys:(keyof RunnerBase)[]=[\n  \"watch\",\n  \"filter\",\n  \"pre\",\n  \"type\",          \n  \"name\",\n  \"full_pathname\",\n  \"script\",\n  \"autorun\",      \n  \"state\",     \n  \"last_start_time\",\n  \"last_end_time\",\n  \"start_time\",\n  \"reason\",  \n  \"last_reason\",\n  \"last_err\",\n  \"output\",\n  \"id\"\n]\n\nexport interface Runner extends RunnerBase{\n  abort_controller: AbortController\n  child           : ChildProcessWithoutNullStreams|undefined\n  start           : (reason:string)=>Promise<void>    \n}\n\nexport interface Folder{\n  type:'folder'\n  name:string \n  full_pathname: string //where the package.json is \n  folders:Array<Folder>\n  runners:Array<Runner>\n  scriptsmon:Scriptsmon\n}\nfunction is_valid_watch(a:unknown){\n  if (a==null)\n    return true\n  return is_string_array(a)\n}\nfunction is_valid_watcher(a:unknown){\n  if (typeof a==='string' || is_string_array(a))\n      return true \n  if (!is_object(a))\n    return \"expecting object\"\n  if (!is_valid_watch(a.watch)){\n    return 'watch: expecting  array of strings'\n  }\n\n  for (const k of Object.keys(a))\n    if (!['watch','env','filter','pre'].includes(k))\n      return `${k}:invalid key`\n  return true\n}\nfunction is_non_watcher(k:string){\n  return  (['autorun','$watch'].includes(k))\n}\nfunction is_config2(a:unknown){\n  if (!is_object(a))\n    return false\n  const {$watch}=a\n  if (!is_valid_watch($watch)){\n    console.log('watch: must be string or array of string')\n    return false  \n  }\n  for (const [k,v] of Object.entries(a)){\n    if (is_non_watcher(k))\n      continue\n    const valid_watcher=is_valid_watcher(v)\n    if (valid_watcher!==true){\n      console.log(`${k}: invalid watcher:${valid_watcher}`)\n      return false\n    }\n\n  }\n  return true\n\n}\nfunction parse_config(filename:string,pkgJson:s2u|undefined):Scriptsmon{\n  if (pkgJson==null)\n    return{}\n  const {scriptsmon}=pkgJson\n  if (scriptsmon==null)\n    return {}\n  const ans=is_config2(scriptsmon);\n  if (ans)\n    return scriptsmon as Scriptsmon\n  console.warn(ans)\n  return {}  \n}\nfunction parse_scripts(pkgJson:s2u):s2s{\n\n  if (pkgJson==null)\n    return {}\n  const {scripts}=pkgJson\n  if (scripts==null)\n    return {}  \n  return scripts as s2s\n}\nfunction normalize_watch(a:string[]|undefined){\n  if (a==null)\n    return []\n  return a\n}\nfunction run_runner({ //this is not async function on purpuse\n  runner,\n  reason\n}: {\n  runner: Runner;\n  reason:string\n}) {\n  const {abort_controller}=runner\n  const {signal}=abort_controller\n  void new Promise((resolve, _reject) => { \n    const {script,full_pathname}=runner\n    runner.state='spawning'\n    const child = spawn(script, {\n      signal,\n      shell: true,\n      env: { ...process.env, FORCE_COLOR: \"1\",cwd:full_pathname },  \n    });\n    if (child===null)\n      return\n    child.stdout.on(\"data\",(data:unknown)=>runner.output.push({data:String(data),type:'stdout'}))\n    child.stderr.on(\"data\",(data:unknown)=>runner.output.push({data:String(data),type:'stdout'}))\n    child.on('spawn',()=>{\n      runner.start_time=Date.now()\n      runner.state='running'\n      runner.reason=reason\n    })\n\n    child.on(\"exit\", (code) => {\n      runner.state=(code===0?'done':'crashed') //todo: should think of aborted\n      runner.last_end_time=Date.now()\n      runner.last_start_time=runner.start_time\n      runner.start_time=undefined\n      runner.last_reason=runner.reason\n      resolve(null);\n    });\n\n    child.on(\"error\", (err) => {\n      runner.state='failed'\n      runner.last_err=get_error(err)\n      resolve(null);\n    });\n  });\n}\nasync function stop(runner: Runner): Promise<void> {\n  const { state,abort_controller,abort_controller:{signal} } = runner;\n  let was_stopped=false\n  while(true){\n    if (is_ready_to_start(runner.state)) {\n      if (was_stopped)\n        runner.state='stopped'\n      return Promise.resolve()\n    }\n    signal.addEventListener('abort', () => was_stopped=true, { once: true });\n    await sleep(10)\n  }\n}\nfunction make_start(runner:Runner){\n  return  async function(reason:string){\n    await stop(runner)\n    run_runner({runner,reason})\n\n  }\n  \n}\nfunction scriptsmon_to_runners(pkgPath:string,watchers:Scriptsmon,scripts:s2s){\n  const $watch=normalize_watch(watchers.$watch)\n  const autorun=normalize_watch(watchers.autorun)\n  const ans=[]\n  for (const [name,script] of Object.entries(scripts)){\n    if (is_non_watcher(name))\n      continue\n    const watcher:Watcher=function(){\n      const v=watchers[name]\n      if (v==null||is_string_array(v)){\n        return {watch:normalize_watch(v)}\n      }\n      return v\n    }()\n    //const script=scripts[name]\n    if (script==null){\n      console.warn(`missing script ${name}`)\n      continue\n    }\n    const runner=function(){\n      const full_pathname=path.dirname(pkgPath)\n      const id=`${full_pathname} ${name}`.replaceAll(/\\\\|:/g,'-').replaceAll(' ','--')\n      const ans:Runner= {\n        type:'runner',\n        ...watcher, //i like this\n        name,\n        script,\n        full_pathname,\n        watch:[...normalize_watch($watch),...normalize_watch(watcher.watch)],\n        autorun:autorun.includes(name),\n        state:'ready',\n        child:undefined,\n        start_time:0,\n        last_end_time:undefined,\n        last_start_time:undefined,\n        start:(reason:string)=>Promise.resolve(),\n        reason:'',\n        last_reason:'',\n        last_err:undefined,\n        abort_controller:new AbortController(),\n        output:[],\n        id\n      }\n      ans.start=make_start(ans)\n      return ans\n    }()\n    ans.push(runner)\n  }\n  return ans\n}\nexport async function read_package_json(\n  full_pathnames: string[]\n) {\n\n  const folder_index: Record<string, Folder> = {}; //by full_pathname\n  async function f(full_pathname: string,name:string){\n    const pkgPath = path.resolve(path.normalize(full_pathname), \"package.json\");\n    const d= path.resolve(full_pathname);\n    const exists=folder_index[d]\n    if (exists!=null){\n      console.warn(`${pkgPath}: skippin, already done`)\n      return exists\n    }    \n    //const pkgJson = await \n    const pkgJson=await read_json_object(pkgPath,'package.json')\n    if (pkgJson==null)\n      return null\n    console.warn(`${green}${pkgPath}${reset}`)\n    const scriptsmon=parse_config(pkgPath,pkgJson)\n    const scripts=parse_scripts(pkgJson)\n    const runners=scriptsmon_to_runners(pkgPath,scriptsmon,scripts)\n    const {workspaces} = pkgJson\n    const folders=[]\n    if (is_string_array(workspaces))\n      for (const workspace of workspaces){\n          const ret=await f(path.join(full_pathname,workspace),workspace)\n          if (ret!=null)\n            folders.push(ret)\n        }\n\n    \n    const ans:Folder= {runners,folders,name,full_pathname,scriptsmon,type:'folder'}\n    return ans\n  }\n  const folders=[]\n  for (const pathname of full_pathnames){\n    const full_pathname=path.resolve(pathname)\n    const ret=await f(full_pathname,path.basename(full_pathname))\n      if (ret!=null)\n        folders.push(ret)\n  }\n  const root:Folder={\n    name:'root',\n    full_pathname: '',\n    folders,\n    runners:[],\n    scriptsmon:{},\n    type:'folder'\n  }\n  //const keys=Object.keys(ans)\n  //const common_prefix=getCommonPrefix(keys)\n  //const extra={keys,common_prefix}\n  //await mkdir_write_file('generated/extra.json',JSON.stringify(extra,null,2))\n  await mkdir_write_file('c:\\\\yigal\\\\generated\\\\packages.json',JSON.stringify(root,null,2))\n  return root\n}\n", "export type s2t<T> = Record<string, T>\nexport type s2u = Record<string, unknown>\nexport type p2u = Record<PropertyKey, unknown> \nexport const green='\\x1b[40m\\x1b[32m'\nexport const red='\\x1b[40m\\x1b[31m'\nexport const yellow='\\x1b[40m\\x1b[33m'\n\nexport const reset='\\x1b[0m'\nexport function nl<T>(value: T | null | undefined): T {\n  //todo:check only active on debug mode\n  //return value\n  if (value === null || value === undefined) {\n    throw new Error('Value cannot be null or undefined')\n  }\n  return value\n}\nexport type Key = number | string //should i use properykey for this?\nexport type Atom = number | string | boolean \nexport function is_atom(x: unknown): x is Atom {\n  if (x == null) return false\n  return ['number', 'string', 'boolean'].includes(typeof x)\n}\nexport function is_key(x: unknown): x is Key {\n  if (x == null) return false\n  return ['number', 'string'].includes(typeof x)\n}\nexport function is_atom_ex(v: unknown, place: string, k = ''): v is Atom {\n  if (is_atom(v)) return true\n  console.warn('non-atom', place, k, v)\n  return false\n}\nexport function get_error(x:unknown){\n  if (x instanceof Error)\n    return x\n  const str = String(x)\n  return new Error(str)\n}\nexport function is_object<T extends object=s2u>(value: unknown): value is T{\n  if (value == null) return false;\n  \n  // Accept objects and functions\n  if (typeof value !== 'object' && typeof value !== 'function') return false;\n  \n  // Exclude known non-object types\n  if (Array.isArray(value)) return false;\n  if (value instanceof Set) return false;\n  if (value instanceof Map) return false;\n  \n  return true;\n}\nexport function has_key(obj: unknown, k: string): boolean {\n  if (!is_object(obj)) return false\n  return k in obj\n}\nexport function* objects_only(ar:unknown[]){\n  for (const item of ar)\n    if (is_object(item))\n      yield item\n}\n\nexport function has_keys(obj: unknown, keys: string[]): boolean {\n  if (!is_object(obj)) return false\n  for (const k of keys) if (k in keys) return true\n  return false\n}\nexport type strset = Set<string>\nexport type s2num = Record<string, number>\nexport type s2s = Record<string, string>\nexport type num2num = Record<number, number>\n\nexport function pk<T, K extends keyof T>(obj: T | undefined, ...keys: K[]): Pick<T, K> {\n  const ret: Record<PropertyKey,unknown> = {} \n  keys.forEach((key) => {\n    ret[key] = obj?.[key]\n  })\n  return ret as Pick<T, K> \n}\nexport function is_promise<T=void>(value: unknown): value is Promise<T> { ///ts(2677)\n  if (!is_object(value))\n    return false\n\n  const ans=typeof (value.then)==='function'\n  return ans\n}\ntype MaybePromise<T>=T|Promise<T>\nasync function resolve_maybe_promise<T>(a:MaybePromise<T>){\n  if (is_promise(a))\n    return await a\n  return a\n}\n      \nexport interface Test{\n  k?:string,\n  v?:Atom,\n  f:()=>MaybePromise<Atom>\n}\n\nexport async function run_tests(...tests: Test[]) {\n  let passed = 0\n  let failed = 0\n  \n  for (const {k,v,f} of tests) {\n    const ek=function(){\n      if (k!=null)\n        return k\n      const fstr=String(f)\n      {\n        const match=fstr.match(/(\\(\\) => )(.*)/)\n        if (match?.length===3)\n          return match[2]\n      }\n      {\n        const match=fstr.match(/function\\s(\\w+)/)\n        if (match?.length===2)\n          return match[1]      \n      }\n      return\n    }()\n    try {\n      const ret=f()\n      const effective_v=v??true\n      const resolved = await resolve_maybe_promise(ret)\n      if (resolved===effective_v){\n        console.log(`\u2705 ${ek}: ${green}${effective_v}${reset}`)\n        passed++\n      } else {\n        console.error(`\u274C ${ek}:expected ${yellow}${effective_v}${reset}, got ${red}${resolved}${reset}`)\n        failed++\n      }\n    } catch (err) {\n      console.error(`\uD83D\uDCA5 ${ek} threw an error:`, err)\n      failed++\n    }\n  }\n  if (failed===0)\n    console.log(`\\nSummary:  all ${passed} passed`)  \n  else\n    console.log(`\\nSummary:  ${failed} failed, ${passed} passed`)  \n}\n\n\nexport function getCommonPrefix(paths: string[]): string {\n  if (paths.length === 0) return \"\";\n  if (paths.length === 1) return paths[0];\n\n  // Split each path into parts (e.g., by \"/\" or \"\\\\\")\n  const splitPaths = paths.map(p => p.split(/[\\\\/]+/));\n\n  const commonParts: string[] = [];\n  const first = splitPaths[0];\n\n  for (let i = 0; i < first.length; i++) {\n    const part = first[i];\n    if (splitPaths.every(p => p[i] === part)) {\n      commonParts.push(part);\n    } else {\n      break;\n    }\n  }\n\n  // Join back with \"/\" (or use path.join for platform-specific behavior)\n  return commonParts.join(\"/\");\n}\n\n\nasync function get_node(){\n  if (typeof window !== \"undefined\") {\n    throw new Error(\"getFileContents() requires Node.js\");\n  }\n  const path = await import(\"node:path\");\n  const fs = await import(\"node:fs/promises\");\n  return {fs,path}  \n}\nexport async function mkdir_write_file(filePath:string,data:string){\n  const {path,fs}=await get_node()\n  const directory=path.dirname(filePath);\n  try{\n    await fs.mkdir(directory,{recursive:true});\n    await fs.writeFile(filePath,data);\n    console.log(`File '${filePath}' has been written successfully.`);\n  } catch (err){\n    console.error('Error writing file',err)\n  }\n}\nexport async function read_json_object(filename:string,object_type:string){\n  const {fs}=await get_node()\n  try{\n    const data=await fs.readFile(filename, \"utf-8\");\n    const ans=JSON.parse(data) as unknown\n    if (!is_object(ans))\n      throw `not a valid ${object_type}`\n    return ans\n  }catch(ex:unknown){\n    console.warn(`${filename}:${get_error(ex)}.message`)\n    return undefined\n  }\n}\nexport function is_string_array(a:unknown):a is string[]{\n  if (!Array.isArray(a))\n    return false\n  for (const x of a)\n    if (typeof x!=='string')\n      return false\n  return true  \n}\n\nexport async function sleep(ms: number) {\n  return await new Promise((resolve) => {\n    setTimeout(() => resolve(undefined), ms);\n  });\n}"],
  "mappings": "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",
  "names": ["path", "path", "fs", "resolve", "resolve", "ans", "folders", "workspace", "root"]
}
